import os
import errno
import copy
import json
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

np.set_printoptions(linewidth=500)


class HighSidebandCCD(CCD):
    def __init__(self, hsg_thing, parameter_dict=None, spectrometer_offset=None):
        """
        This will read the appropriate file.  The header needs to be fixed to
        reflect the changes to the output header from the Andor file.  Because
        another helper file will do the cleaning and background subtraction,
        those are no longer part of this init.  This also turns all wavelengths
        from nm (NIR ones) or cm-1 (THz ones) into eV.

        OR, if an array is thrown in there, it'll handle the array and dict

        Input:
            For post-processing analysis:
                hsg_thing = file name of the hsg spectrum from CCD superclass
                spectrometer_offset = number of nanometers the spectrometer is off by,
                                      should be 0.0...but can be 0.2 or 1.0
            For Live-software:
                hsg_thing = np array of spectrum from camera
                parameter_dict = equipment dict generated by software

        Internal:
        self.hsg_thing = the filename
        self.parameters = string with all the relevant experimental perameters
        self.description = the description we added to the file as the data
                           was being taken
        self.proc_data = processed data that has gone is frequency vs counts/pulse
        self.dark_stdev = this is not currently handled appropriately
        self.addenda = the list of things that have been added to the file, in
                       form of [constant, *spectra_added]
        self.subtrahenda = the list of spectra that have been subtracted from
                           the file.  Constant subtraction is dealt with with
                           self.addenda

        :param hsg_thing: file name for the file to be opened.  OR the actually hsg np.ndarray.  Fun!
        :type hsg_thing: str OR np.ndarray
        :param parameter_dict: If being loaded through the data acquisition GUI, throw the dict in here
        :type parameter_dict: dict
        :param spectrometer_offset: Number of nm the spectrometer is off by
        :type spectrometer_offset: float
        :return: None, technically
        """
        if isinstance(hsg_thing, str):
            super(HighSidebandCCD, self).__init__(hsg_thing, spectrometer_offset=spectrometer_offset)
            # TODO: fix addenda bullshit
            self.addenda = []
            self.subtrahenda = []
        elif isinstance(hsg_thing, np.ndarray):
            self.parameters = parameter_dict.copy()  # Probably shouldn't shoehorn this in this way
            self.addenda = []
            self.subtrahenda = []
            self.ccd_data = np.array(hsg_thing)
            self.ccd_data[:, 0] = 1239.84 / self.ccd_data[:, 0]
            # This data won't have an error column, so attached a column of ones
            self.ccd_data = np.column_stack((self.ccd_data, np.ones_like(self.ccd_data[:,1])))
            self.ccd_data = np.flipud(self.ccd_data) # Because turning into eV switches direction
            self.fname = "Live Data"
        else:
            raise Exception("I don't know what this file type is {}, type: {}".format(
                hsg_thing, type(hsg_thing)
            ))
        self.proc_data = np.array(self.ccd_data)
        # proc_data is now a 1600 long array with [frequency (eV), signal (counts / FEL pulse), S.E. of signal mean]

        # self.parameters["nir_freq"] = 1239.84 / float(self.parameters["nir_lambda"])
        self.parameters["nir_freq"] = 1239.84 / float(self.parameters.get("nir_lambda", -1))
        # self.parameters["thz_freq"] = 0.000123984 * float(self.parameters["fel_lambda"])
        self.parameters["thz_freq"] = 0.000123984 * float(self.parameters.get("fel_lambda", -1))
        # self.parameters["nir_power"] = float(self.parameters["nir_power"])
        self.parameters["nir_power"] = float(self.parameters.get("nir_power", -1))
        try: # This is the new way of doing things.  Also, now it's power
            self.parameters["thz_energy"] = float(self.parameters["pulseEnergies"]["mean"])
            self.parameters["thz_energy_std"] = float(self.parameters["pulseEnergies"]["std"])
        except: # This is the old way TODO: DEPRECATE THIS
            self.parameters["thz_energy"] = float(self.parameters.get("fel_power", -1))

        # things used in fitting/guessing
        self.sb_list = np.array([])
        self.sb_index = np.array([])
        self.sb_dict = {}
        self.sb_results = np.array([])
        self.full_dict = {}

    def __add__(self, other):
        """
        Add together the image data from self.proc_data, or add a constant to
        that np.array.  It will then combine the addenda and subtrahenda lists,
        as well as add the fel_pulses together.  If type(other) is a CCD object,
        then it will add the errors as well.

        Input:
        self = CCD-like object
        other = int, float or CCD object

        Internal:
        ret.proc_data = the self.proc_data + other(.proc_data)
        ret.addenda = combination of two input addenda lists

        This raises a FutureWarning because these were designed early on and
        haven't been used much.

        :param other: The thing to be added, it's either a int/float or a HighSidebandCCD object
        :type other: int/float or HighSidebandCCD
        :return: Sum of self and other
        :rtype: HighSidebandCCD
        """
        raise FutureWarning
        ret = copy.deepcopy(self)
        # Add a constant offset to the data
        if type(other) in (int, float):
            ret.proc_data[:, 1] = self.proc_data[:, 1] + other
            ret.addenda[0] = ret.addenda[0] + other

        # or add the data of two hsg_spectra together
        else:
            if np.isclose(ret.parameters['center_lambda'], other.parameters['center_lambda']):
                ret.proc_data[:, 1] = self.proc_data[:, 1] + other.proc_data[:, 1]
                ret.proc_data[:, 2] = np.sqrt(self.proc_data[:, 1] ** 2 + other.proc_data[:, 1] ** 2)
                ret.addenda[0] = ret.addenda[0] + other.addenda[0]
                ret.addenda.extend(other.addenda[1:])
                ret.subtrahenda.extend(other.subtrahenda)
                ret.parameters['fel_pulses'] += other.parameters['fel_pulses']
            else:
                raise Exception('Source: Spectrum.__add__:\nThese are not from the same grating settings')
        return ret

    def __sub__(self, other):
        """
        This subtracts constants or other data sets between self.proc_data.  I
        think it even keeps track of what data sets are in the file and how
        they got there.

        See how __add__ works for more information.

        This raises a FutureWarning because these were designed early on and
        haven't been used much.

        :param other: The thing to be subtracted, it's either a int/float or a HighSidebandCCD object
        :type other: int/float or HighSidebandCCD
        :return: Sum of self and other
        :rtype: HighSidebandCCD
        """
        raise FutureWarning
        ret = copy.deepcopy(self)
        # Subtract a constant offset to the data
        if type(other) in (int, float):
            ret.proc_data[:, 1] = self.proc_data[:, 1] - other  # Need to choose a name
            ret.addenda[0] = ret.addenda[0] - other

        # Subtract the data of two hsg_spectra from each other
        else:
            if np.isclose(ret.proc_data[0, 0], other.proc_data[0, 0]):
                ret.proc_data[:, 1] = self.proc_data[:, 1] - other.proc_data[:, 1]
                ret.proc_data[:, 2] = np.sqrt(self.proc_data[:, 1] ** 2 + other.proc_data[:, 1] ** 2)
                ret.subtrahenda.extend(other.addenda[1:])
                ret.addenda.extend(other.subtrahenda)
            else:
                raise Exception('Source: Spectrum.__sub__:\nThese are not from the same grating settings')
        return ret

    def __repr__(self):
        base = """
            fname: {},
            Series: {series},
            spec_step: {spec_step},
            fel_lambda: {fel_lambda},
            nir_lambda: {nir_lambda}""".format(os.path.basename(self.fname),**self.parameters)
        return base

    __str__ = __repr__

    def calc_approx_sb_order(self, test_nir_freq):
        """
        This simple method will simply return a float approximating the order
        of the frequency input.  We need this because the CCD wavelength
        calibration is not even close to perfect.  And it shifts by half a nm
        sometimes.

        :param test_nir_freq: the frequency guess of the nth sideband
        :type test_nir_freq: float
        :return: The approximate order of the sideband in question
        :rtype: float
        """
        nir_freq = self.parameters['nir_freq']
        thz_freq = self.parameters['thz_freq']
        # If thz = 0, prevent error
        if not thz_freq: thz_freq = 1
        approx_order = (test_nir_freq - nir_freq) / thz_freq
        return approx_order

    def guess_sidebands(self, cutoff=4.5, verbose=False, plot=False, **kwargs):
        """
        Update 05/24/18:
        Hunter had two different loops for negative order sidebands,
        then positive order sidebands. They're done pretty much identically,
        so I've finally merged them into one.

        Finds the locations of all the sidebands in the proc_data array to be
        able to seed the fitting method.  This works by finding the maximum data
        value in the array and guessing what sideband it is.  It creates an array
        that includes this information.  It will then step down, initially by one
        THz frequency, then by twos after it hasn't found any odd ones.  It then
        goes up from the max and finds everything above in much the same way.

        There is currently no rhyme or reason to a cutoff of 8.  I don't know what
        it should be changed to, though.

        Input:
        cutoff = signal-to-noise threshold to count a sideband candidate.

        kwargs:
           window_size: how big of a window (in pixels) to use for checking for
                sidebands. Specified in half-width
              default: 15


        Internal:
        self.sb_list = List of all of the orders the method found
        self.sb_index = index of all of the peaks of the sidebands
        self.sb_guess = three-part list including the frequency, amplitude and
                        error guesses for each sideband
        """
        # TODO: this isn't commented appropriately.  Will it be made more readable first?

        if "cutoff" in self.parameters:
            cutoff = self.parameters["cutoff"]
        else:
            self.parameters['cutoff for guess_sidebands'] = cutoff

        if verbose:
            print("=" * 15)
            print()
            print("Guessing CCD Sideband parameters")
            print(os.path.basename(self.fname))
            print("\tCutoff = {}".format(cutoff))
            print()
            print("=" * 15)
        x_axis = np.array(self.proc_data[:, 0])
        y_axis = np.array(self.proc_data[:, 1])
        try:
            error = np.array(self.proc_data[:, 2])
        except IndexError:
            # Happens on old data where spectra weren't calculated in the live
            # software.
            error = np.ones_like(x_axis)

        min_sb = int(self.calc_approx_sb_order(x_axis[0])) + 1
        try:
            max_sb = int(self.calc_approx_sb_order(x_axis[-1]))
        except ValueError:
            print(x_axis)

        nir_freq = self.parameters["nir_freq"]
        thz_freq = self.parameters["thz_freq"]

        if verbose:
            print("min_sb: {} | max_sb: {}".format(min_sb, max_sb))

        # Find max strength sideband and it's order
        global_max = np.argmax(y_axis)
        order_init = int(round(self.calc_approx_sb_order(x_axis[global_max])))
        # if verbose:
        #     print "The global max is at index", global_max
        if global_max < 15:
            check_y = y_axis[:global_max + 15]
            check_y = np.concatenate((np.zeros(15 - global_max), check_y))
        elif global_max > 1585:
            check_y = y_axis[global_max - 15:]
            check_y = np.concatenate((check_y, np.zeros(global_max - 1585)))
        else:
            check_y = y_axis[global_max - 15:global_max + 15]

        check_max_index = np.argmax(check_y)
        check_max_area = np.sum(check_y[check_max_index - 2:check_max_index + 3])

        check_ave = np.mean(check_y[[0, 1, 2, 3, 4, -1, -2, -3, -4, -5]])
        check_stdev = np.std(check_y[[0, 1, 2, 3, 4, -1, -2, -3, -4, -5]])
        check_ratio = (check_max_area - 3 * check_ave) / check_stdev

        if verbose:
            print(("{:^16}" * 5).format(
                "global_max idx", "check_max_area", "check_ave", "check_stdev",
                "check_ratio"))
            print(("{:^16.5g}" * 5).format(
                global_max, check_max_area, check_ave, check_stdev, check_ratio))

        if check_ratio > cutoff:
            self.sb_list = [order_init]
            self.sb_index = [global_max]
            sb_freq_guess = [x_axis[global_max]]
            sb_amp_guess = [y_axis[global_max]]
            sb_error_est = [
                np.sqrt(sum([i ** 2 for i in error[global_max - 2:global_max + 3]])) / (
                            check_max_area - 5 * check_ave)]
        else:
            print("There are no sidebands in", self.fname)
            raise RuntimeError

        if verbose:
            print("\t Looking for sidebands with f < {:.6f}".format(sb_freq_guess[0]))
        last_sb = sb_freq_guess[0]
        index_guess = global_max
        # keep track of how many consecutive sidebands we've skipped. Sometimes one's
        #  noisy or something, so we want to keep looking after skipping one
        consecutive_null_sb = 0
        consecutive_null_odd = 0
        no_more_odds = False
        break_condition = False
        for order in range(order_init - 1, min_sb - 1, -1):
            # Check to make sure we're not looking at an odd when
            # we've decided to skip them.
            if no_more_odds == True and order % 2 == 1:
                last_sb = last_sb - thz_freq
                if verbose:
                    print("I skipped", order)
                continue

            # Window size to look for next sideband. Needs to be order dependent
            # because higher orders get wider, so we need to look at more.
            # Values are arbitrary.
            window_size = 0.45 + 0.0004 * order  # used to be last_sb?
            lo_freq_bound = last_sb - thz_freq * (
                        1 + window_size)  # Not sure what to do about these
            hi_freq_bound = last_sb - thz_freq * (1 - window_size)

            if verbose:
                print("\nSideband", order)
                print("\t{:.4f} < f_{} < {:.4f}".format(lo_freq_bound, order,
                                                        hi_freq_bound))

            # Get the indices where the energies lie within the bounds for this SB
            sliced_indices = \
            np.where((x_axis > lo_freq_bound) & (x_axis < hi_freq_bound))[0]
            start_index, end_index = sliced_indices.min(), sliced_indices.max()

            # Get a slice of the y_data which is only in the region of interest
            check_y = y_axis[sliced_indices]

            check_max_index = np.argmax(
                check_y)  # This assumes that two floats won't be identical
            # Calculate the "area" of the sideband by looking at the peak value
            # within the range, and the pixel above/below it
            check_max_area = np.sum(check_y[check_max_index - 1:check_max_index + 2])

            if verbose and plot:
                plt.figure("CCD data")
                plt.plot([lo_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([hi_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([lo_freq_bound, hi_freq_bound], [check_y[check_max_index]] *
                         2, 'b', label="{} Box".format(order))
                plt.text((lo_freq_bound + hi_freq_bound) / 2, check_y[check_max_index],
                         order)

            # get the slice that doesn't have the peak in it to compare statistics
            check_region = np.append(check_y[:check_max_index - 1],
                                     check_y[check_max_index + 2:])
            check_ave = check_region.mean()
            check_stdev = check_region.std()

            # Calculate an effective SNR, where check_ave is roughly the
            # background level
            check_ratio = (check_max_area - 3 * check_ave) / check_stdev

            if order % 2 == 1:  # This raises the barrier for odd sideband detection
                check_ratio = check_ratio / 1.5
            if verbose:
                print("\t" + ("{:^14}" * 4).format(
                    "check_max_area", "check_ave", "check_stdev", "check_ratio"))
                print("\t" + ("{:^14.5g}" * 4).format(
                    check_max_area, check_ave, check_stdev, check_ratio))

            if check_ratio > cutoff:
                found_index = check_max_index + start_index
                self.sb_index.append(found_index)
                last_sb = x_axis[found_index]

                if verbose:
                    print("I just found", last_sb)

                sb_freq_guess.append(x_axis[found_index])
                sb_amp_guess.append(check_max_area - 3 * check_ave)
                error_est = np.sqrt(
                    sum(
                        [i ** 2 for i in error[found_index - 1:found_index + 2]]
                    )) / (check_max_area - 3 * check_ave)
                if verbose:
                    print("My error estimate is:", error_est)
                sb_error_est.append(error_est)
                self.sb_list.append(order)
                consecutive_null_sb = 0
                if order % 2 == 1:
                    consecutive_null_odd = 0
            else:
                # print "I could not find sideband with order", order
                last_sb = last_sb - thz_freq
                consecutive_null_sb += 1
                if order % 2 == 1:
                    consecutive_null_odd += 1
            if consecutive_null_odd == 1 and no_more_odds == False:
                # print "I'm done looking for odd sidebands"
                no_more_odds = True
            if consecutive_null_sb == 2:
                # print "I can't find any more sidebands"
                break

        # Look for higher sidebands
        if verbose: print("\nLooking for higher energy sidebands")

        last_sb = sb_freq_guess[0]
        index_guess = global_max
        consecutive_null_sb = 0
        consecutive_null_odd = 0
        no_more_odds = False
        break_condition = False
        for order in range(order_init + 1, max_sb + 1):
            if no_more_odds == True and order % 2 == 1:
                last_sb = last_sb + thz_freq
                continue
            window_size = 0.45 + 0.001 * order  # used to be 0.28 and 0.0004
            lo_freq_bound = last_sb + thz_freq * (
                        1 - window_size)  # Not sure what to do about these
            hi_freq_bound = last_sb + thz_freq * (1 + window_size)

            start_index = False
            end_index = False

            if verbose:
                print("\nSideband", order)
                # print "The low frequency bound is", lo_freq_bound
                # print "The high frequency bound is", hi_freq_bound
                print("\t{:.4f} < f_{} < {:.4f}".format(lo_freq_bound, order,
                                                        hi_freq_bound))
            for i in range(index_guess, 1600):
                if start_index == False and i == 1599:
                    # print "I'm all out of space, captain!"
                    break_condition = True
                    break
                elif start_index == False and x_axis[i] > lo_freq_bound:
                    # print "start_index is", i
                    start_index = i
                elif i == 1599:
                    end_index = 1599
                    # print "hit end of data, end_index is 1599"
                elif end_index == False and x_axis[i] > hi_freq_bound:
                    end_index = i
                    # print "end_index is", i
                    index_guess = i
                    break
            if break_condition:
                break
            check_y = y_axis[start_index:end_index]

            check_max_index = np.argmax(
                check_y)  # This assumes that two floats won't be identical
            octant = len(check_y) // 8  # To be able to break down check_y into eighths
            if octant < 1:
                octant = 1

            check_max_area = np.sum(
                check_y[check_max_index - octant - 1:check_max_index + octant + 1])

            if verbose and plot:
                plt.figure("CCD data")
                plt.plot([lo_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([hi_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([lo_freq_bound, hi_freq_bound], [check_y[check_max_index]] *
                         2, 'b', label=order)
                plt.text((lo_freq_bound + hi_freq_bound) / 2, check_y[check_max_index],
                         order)

            no_peak = (2 * len(
                check_y)) // 6  # The denominator is in flux, used to be 5
            # if verbose: print "\tcheck_y length", len(check_y)

            check_ave = np.mean(np.take(check_y, np.concatenate(
                (np.arange(no_peak), np.arange(-no_peak, 0)))))
            check_stdev = np.std(np.take(check_y, np.concatenate(
                (np.arange(no_peak), np.arange(-no_peak, 0)))))

            check_ratio = (check_max_area - (2 * octant + 1) * check_ave) / check_stdev

            if verbose:
                print("\tIndices: {}->{} (d={})".format(start_index, end_index,
                                                        len(check_y)))
                # print "check_y is", check_y
                # print "\ncheck_max_area is", check_max_area
                # print "check_ave is", check_ave
                # print "check_stdev is", check_stdev
                # print "check_ratio is", check_ratio

                print("\t" + ("{:^14}" * 4).format(
                    "check_max_area", "check_ave", "check_stdev", "check_ratio"))
                print("\t" + ("{:^14.6g}" * 4).format(
                    check_max_area, check_ave, check_stdev, check_ratio))

            if order % 2 == 1:  # This raises the barrier for odd sideband detection
                check_ratio = check_ratio / 2
            if check_ratio > cutoff:
                found_index = check_max_index + start_index
                self.sb_index.append(found_index)
                last_sb = x_axis[found_index]

                if verbose:
                    print("\tI'm counting this SB at index {} (f={:.4f})".format(
                        found_index, last_sb), end=' ')
                    # print "\tI found", order, "at index", found_index, "at freq", last_sb

                sb_freq_guess.append(x_axis[found_index])
                sb_amp_guess.append(check_max_area - (2 * octant + 1) * check_ave)
                error_est = np.sqrt(sum([i ** 2 for i in error[
                                                         found_index - octant:found_index + octant]])) / (
                                    check_max_area - (2 * octant + 1) * check_ave)
                # This error is a relative error.
                if verbose:
                    print(". Err = {:.3g}".format(error_est))
                    # print "\tMy error estimate is:", error_est
                # print "My relative error is:", error_est / sb_amp_guess
                sb_error_est.append(error_est)
                self.sb_list.append(order)
                consecutive_null_sb = 0
                if order % 2 == 1:
                    consecutive_null_odd = 0
            else:
                # print "I could not find sideband with order", order
                last_sb = last_sb + thz_freq
                consecutive_null_sb += 1
                if order % 2 == 1:
                    consecutive_null_odd += 1
                if verbose:
                    print("\t\tI did not count this sideband")
            if consecutive_null_odd == 1 and no_more_odds == False:
                # print "I'm done looking for odd sidebands"
                no_more_odds = True
            if consecutive_null_sb == 2:
                # print "I can't find any more sidebands"
                break

        if verbose:
            print("I found these sidebands:", self.sb_list)
            print('-' * 15)
            print()
            print()
        self.sb_guess = np.array([np.asarray(sb_freq_guess), np.asarray(sb_amp_guess),
                                  np.asarray(sb_error_est)]).T
        # self.sb_guess = [frequency guess, amplitude guess, relative error of amplitude] for each sideband.

    def guess_sidebandsOld(self, cutoff=4.5, verbose=False, plot=False, **kwargs):
        """
        05/24/18
        Old code from Hunter's days (or nearly, I've already started cleaning some
        stuff up). keeping it around in case I break too much stuff

        Finds the locations of all the sidebands in the proc_data array to be
        able to seed the fitting method.  This works by finding the maximum data
        value in the array and guessing what sideband it is.  It creates an array
        that includes this information.  It will then step down, initially by one
        THz frequency, then by twos after it hasn't found any odd ones.  It then
        goes up from the max and finds everything above in much the same way.

        There is currently no rhyme or reason to a cutoff of 8.  I don't know what
        it should be changed to, though.

        Input:
        cutoff = signal-to-noise threshold to count a sideband candidate.

        kwargs:
           window_size: how big of a window (in pixels) to use for checking for
                sidebands. Specified in half-width
              default: 15


        Internal:
        self.sb_list = List of all of the orders the method found
        self.sb_index = index of all of the peaks of the sidebands
        self.sb_guess = three-part list including the frequency, amplitude and
                        error guesses for each sideband
        """
        # TODO: this isn't commented appropriately.  Will it be made more readable first?

        if "cutoff" in self.parameters:
            cutoff = self.parameters["cutoff"]
        else:
            self.parameters['cutoff for guess_sidebands'] = cutoff

        if verbose:
            print("=" * 15)
            print()
            print("Guessing CCD Sideband parameters")
            print(os.path.basename(self.fname))
            print("\tCutoff = {}".format(cutoff))
            print()
            print("=" * 15)
        x_axis = np.array(self.proc_data[:, 0])
        y_axis = np.array(self.proc_data[:, 1])
        error = np.array(self.proc_data[:, 2])

        min_sb = int(self.calc_approx_sb_order(x_axis[0])) + 1
        try:
            max_sb = int(self.calc_approx_sb_order(x_axis[-1]))
        except ValueError:
            print(x_axis)

        nir_freq = self.parameters["nir_freq"]
        thz_freq = self.parameters["thz_freq"]

        if verbose:
            print("min_sb: {} | max_sb: {}".format(min_sb, max_sb))

        # Find max strength sideband and it's order
        global_max = np.argmax(y_axis)
        order_init = int(round(self.calc_approx_sb_order(x_axis[global_max])))
        # if verbose:
        #     print "The global max is at index", global_max
        if global_max < 15:
            check_y = y_axis[:global_max + 15]
            check_y = np.concatenate((np.zeros(15 - global_max), check_y))
        elif global_max > 1585:
            check_y = y_axis[global_max - 15:]
            check_y = np.concatenate((check_y, np.zeros(global_max - 1585)))
        else:
            check_y = y_axis[global_max - 15:global_max + 15]

        check_max_index = np.argmax(check_y)
        check_max_area = np.sum(check_y[check_max_index - 2:check_max_index + 3])

        check_ave = np.mean(check_y[[0, 1, 2, 3, 4, -1, -2, -3, -4, -5]])
        check_stdev = np.std(check_y[[0, 1, 2, 3, 4, -1, -2, -3, -4, -5]])
        check_ratio = (check_max_area - 3 * check_ave) / check_stdev

        if verbose:
            print(("{:^16}" * 5).format(
                "global_max idx", "check_max_area", "check_ave", "check_stdev",
                "check_ratio"))
            print(("{:^16.5g}" * 5).format(
                global_max, check_max_area, check_ave, check_stdev, check_ratio))

        if check_ratio > cutoff:
            self.sb_list = [order_init]
            self.sb_index = [global_max]
            sb_freq_guess = [x_axis[global_max]]
            sb_amp_guess = [y_axis[global_max]]
            sb_error_est = [
                np.sqrt(sum([i ** 2 for i in error[global_max - 2:global_max + 3]])) / (
                            check_max_area - 5 * check_ave)]
        else:
            print("There are no sidebands in", self.fname)
            raise RuntimeError

        if verbose:
            print("\t Looking for sidebands with f < {:.6f}".format(sb_freq_guess[0]))
        last_sb = sb_freq_guess[0]
        index_guess = global_max
        # keep track of how many consecutive sidebands we've skipped. Sometimes one's
        #  noisy or something, so we want to keep looking after skipping one
        consecutive_null_sb = 0
        consecutive_null_odd = 0
        no_more_odds = False
        break_condition = False
        for order in range(order_init - 1, min_sb - 1, -1):
            # Check to make sure we're not looking at an odd when
            # we've decided to skip them.
            if no_more_odds == True and order % 2 == 1:
                last_sb = last_sb - thz_freq
                if verbose:
                    print("I skipped", order)
                continue

            # Window size to look for next sideband. Needs to be order dependent
            # because higher orders get wider, so we need to look at more.
            # Values are arbitrary.
            window_size = 0.45 + 0.0004 * order  # used to be last_sb?
            lo_freq_bound = last_sb - thz_freq * (
                        1 + window_size)  # Not sure what to do about these
            hi_freq_bound = last_sb - thz_freq * (1 - window_size)

            if verbose:
                print("\nSideband", order)
                print("\t{:.4f} < f_{} < {:.4f}".format(lo_freq_bound, order,
                                                        hi_freq_bound))

            # Get the indices where the energies lie within the bounds for this SB
            sliced_indices = \
            np.where((x_axis > lo_freq_bound) & (x_axis < hi_freq_bound))[0]
            start_index, end_index = sliced_indices.min(), sliced_indices.max()

            # Get a slice of the y_data which is only in the region of interest
            check_y = y_axis[sliced_indices]

            check_max_index = np.argmax(
                check_y)  # This assumes that two floats won't be identical
            # Calculate the "area" of the sideband by looking at the peak value
            # within the range, and the pixel above/below it
            check_max_area = np.sum(check_y[check_max_index - 1:check_max_index + 2])

            if verbose and plot:
                plt.figure("CCD data")
                plt.plot([lo_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([hi_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([lo_freq_bound, hi_freq_bound], [check_y[check_max_index]] *
                         2, 'b', label="{} Box".format(order))
                plt.text((lo_freq_bound + hi_freq_bound) / 2, check_y[check_max_index],
                         order)

            # get the slice that doesn't have the peak in it to compare statistics
            check_region = np.append(check_y[:check_max_index - 1],
                                     check_y[check_max_index + 2:])
            check_ave = check_region.mean()
            check_stdev = check_region.std()

            # Calculate an effective SNR, where check_ave is roughly the
            # background level
            check_ratio = (check_max_area - 3 * check_ave) / check_stdev

            if order % 2 == 1:  # This raises the barrier for odd sideband detection
                check_ratio = check_ratio / 1.5
            if verbose:
                print("\t" + ("{:^14}" * 4).format(
                    "check_max_area", "check_ave", "check_stdev", "check_ratio"))
                print("\t" + ("{:^14.5g}" * 4).format(
                    check_max_area, check_ave, check_stdev, check_ratio))

            if check_ratio > cutoff:
                found_index = check_max_index + start_index
                self.sb_index.append(found_index)
                last_sb = x_axis[found_index]

                if verbose:
                    print("I just found", last_sb)

                sb_freq_guess.append(x_axis[found_index])
                sb_amp_guess.append(check_max_area - 3 * check_ave)
                error_est = np.sqrt(
                    sum(
                        [i ** 2 for i in error[found_index - 1:found_index + 2]]
                    )) / (check_max_area - 3 * check_ave)
                if verbose:
                    print("My error estimate is:", error_est)
                sb_error_est.append(error_est)
                self.sb_list.append(order)
                consecutive_null_sb = 0
                if order % 2 == 1:
                    consecutive_null_odd = 0
            else:
                # print "I could not find sideband with order", order
                last_sb = last_sb - thz_freq
                consecutive_null_sb += 1
                if order % 2 == 1:
                    consecutive_null_odd += 1
            if consecutive_null_odd == 1 and no_more_odds == False:
                # print "I'm done looking for odd sidebands"
                no_more_odds = True
            if consecutive_null_sb == 2:
                # print "I can't find any more sidebands"
                break

        # Look for higher sidebands
        if verbose: print("\nLooking for higher energy sidebands")

        last_sb = sb_freq_guess[0]
        index_guess = global_max
        consecutive_null_sb = 0
        consecutive_null_odd = 0
        no_more_odds = False
        break_condition = False
        for order in range(order_init + 1, max_sb + 1):
            if no_more_odds == True and order % 2 == 1:
                last_sb = last_sb + thz_freq
                continue
            window_size = 0.45 + 0.001 * order  # used to be 0.28 and 0.0004
            lo_freq_bound = last_sb + thz_freq * (
                        1 - window_size)  # Not sure what to do about these
            hi_freq_bound = last_sb + thz_freq * (1 + window_size)

            start_index = False
            end_index = False

            if verbose:
                print("\nSideband", order)
                # print "The low frequency bound is", lo_freq_bound
                # print "The high frequency bound is", hi_freq_bound
                print("\t{:.4f} < f_{} < {:.4f}".format(lo_freq_bound, order,
                                                        hi_freq_bound))
            for i in range(index_guess, 1600):
                if start_index == False and i == 1599:
                    # print "I'm all out of space, captain!"
                    break_condition = True
                    break
                elif start_index == False and x_axis[i] > lo_freq_bound:
                    # print "start_index is", i
                    start_index = i
                elif i == 1599:
                    end_index = 1599
                    # print "hit end of data, end_index is 1599"
                elif end_index == False and x_axis[i] > hi_freq_bound:
                    end_index = i
                    # print "end_index is", i
                    index_guess = i
                    break
            if break_condition:
                break
            check_y = y_axis[start_index:end_index]

            check_max_index = np.argmax(
                check_y)  # This assumes that two floats won't be identical
            octant = len(check_y) // 8  # To be able to break down check_y into eighths
            if octant < 1:
                octant = 1

            check_max_area = np.sum(
                check_y[check_max_index - octant - 1:check_max_index + octant + 1])

            if verbose and plot:
                plt.figure("CCD data")
                plt.plot([lo_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([hi_freq_bound] * 2, [0, check_y[check_max_index]], 'b')
                plt.plot([lo_freq_bound, hi_freq_bound], [check_y[check_max_index]] *
                         2, 'b', label=order)
                plt.text((lo_freq_bound + hi_freq_bound) / 2, check_y[check_max_index],
                         order)

            no_peak = (2 * len(
                check_y)) // 6  # The denominator is in flux, used to be 5
            # if verbose: print "\tcheck_y length", len(check_y)

            check_ave = np.mean(np.take(check_y, np.concatenate(
                (np.arange(no_peak), np.arange(-no_peak, 0)))))
            check_stdev = np.std(np.take(check_y, np.concatenate(
                (np.arange(no_peak), np.arange(-no_peak, 0)))))

            check_ratio = (check_max_area - (2 * octant + 1) * check_ave) / check_stdev

            if verbose:
                print("\tIndices: {}->{} (d={})".format(start_index, end_index,
                                                        len(check_y)))
                # print "check_y is", check_y
                # print "\ncheck_max_area is", check_max_area
                # print "check_ave is", check_ave
                # print "check_stdev is", check_stdev
                # print "check_ratio is", check_ratio

                print("\t" + ("{:^14}" * 4).format(
                    "check_max_area", "check_ave", "check_stdev", "check_ratio"))
                print("\t" + ("{:^14.6g}" * 4).format(
                    check_max_area, check_ave, check_stdev, check_ratio))

            if order % 2 == 1:  # This raises the barrier for odd sideband detection
                check_ratio = check_ratio / 2
            if check_ratio > cutoff:
                found_index = check_max_index + start_index
                self.sb_index.append(found_index)
                last_sb = x_axis[found_index]

                if verbose:
                    print("\tI'm counting this SB at index {} (f={:.4f})".format(
                        found_index, last_sb), end=' ')
                    # print "\tI found", order, "at index", found_index, "at freq", last_sb

                sb_freq_guess.append(x_axis[found_index])
                sb_amp_guess.append(check_max_area - (2 * octant + 1) * check_ave)
                error_est = np.sqrt(sum([i ** 2 for i in error[
                                                         found_index - octant:found_index + octant]])) / (
                                    check_max_area - (2 * octant + 1) * check_ave)
                # This error is a relative error.
                if verbose:
                    print(". Err = {:.3g}".format(error_est))
                    # print "\tMy error estimate is:", error_est
                # print "My relative error is:", error_est / sb_amp_guess
                sb_error_est.append(error_est)
                self.sb_list.append(order)
                consecutive_null_sb = 0
                if order % 2 == 1:
                    consecutive_null_odd = 0
            else:
                # print "I could not find sideband with order", order
                last_sb = last_sb + thz_freq
                consecutive_null_sb += 1
                if order % 2 == 1:
                    consecutive_null_odd += 1
                if verbose:
                    print("\t\tI did not count this sideband")
            if consecutive_null_odd == 1 and no_more_odds == False:
                # print "I'm done looking for odd sidebands"
                no_more_odds = True
            if consecutive_null_sb == 2:
                # print "I can't find any more sidebands"
                break

        if verbose:
            print("I found these sidebands:", self.sb_list)
            print('-' * 15)
            print()
            print()
        self.sb_guess = np.array([np.asarray(sb_freq_guess), np.asarray(sb_amp_guess),
                                  np.asarray(sb_error_est)]).T
        # self.sb_guess = [frequency guess, amplitude guess, relative error of amplitude] for each sideband.

    def fit_sidebands(self, plot=False, verbose=False):
        """
        This takes self.sb_guess and fits to each maxima to get the details of
        each sideband.  It's really ugly, but it works.  The error of the
        sideband area is approximated from the data, not the curve fit.  All
        else is from the curve fit.  Which is definitely underestimating the
        error, but we don't care too much about those errors (at this point).

        self.sb_guess = [frequency guess, amplitude guess, relative error of amplitude] for each sideband.

        Temporary stuff:
        sb_fits = holder of the fitting results until all spectra have been fit
        window = an integer that determines the "radius" of the fit window, proportional to thz_freq.

        Attributes created:
        self.sb_results = the money maker.  Column order:
                          [sb number, Freq (eV), Freq error (eV), Gauss area (arb.), Area error, Gauss linewidth (eV), Linewidth error (eV)]
                          [    0    ,      1   ,        2,      ,        3         ,      4    ,         5           ,        6            ]
        self.full_dict = a dictionary similar to sb_results, but now the keys
                         are the sideband orders.  Column ordering is otherwise the same.
        :param plot: Do you want to see the fits plotted with the data?
        :type plot: bool
        :param verbose: Do you want to see the details AND the initial guess fits?
        :type verbose: bool
        :return: None
        """
        # print "Trying to fit these"
        sb_fits = []

        if verbose:
            print("=" * 15)
            print()
            print("Fitting CCD Sidebands")
            print(os.path.basename(self.fname))
            print()
            print("=" * 15)
        # pretty sure you want this up here so things don't break
        # when no sidebands found
        self.full_dict = {}
        thz_freq = self.parameters["thz_freq"]
        window = 15 + int(15 * thz_freq / 0.0022) # Adjust the fit window based on the sideband spacing
                                                  # The 15's are based on empirical knowledge that for
                                                  # 540 GHz (2.23 meV), the best window size is 30 and
                                                  # that it seems like the window size should grow slowly?
        for elem, peakIdx in enumerate(self.sb_index):  # Have to do this because guess_sidebands
            # doesn't out put data in the most optimized way
            if peakIdx < window:
                data_temp = self.proc_data[:peakIdx + window, :]
            elif (1600 - peakIdx) < window:
                data_temp = self.proc_data[peakIdx - window:, :]
            else:
                data_temp = self.proc_data[peakIdx - window:peakIdx + window, :]
            width_guess = 0.0001 + 0.000001 * self.sb_list[elem]  # so the width guess gets wider as order goes up
            p0 = np.array([self.sb_guess[elem, 0],
                           self.sb_guess[elem, 1] * width_guess,
                           width_guess,
                           0.1])
            # print "Let's fit this shit!"
            if verbose:
                print("Fitting SB {}. Peak index: {}, {}th peak in spectra".format(
                    self.sb_list[elem], peakIdx, elem
                ))
                # print "\nnumber:", elem, num
                # print "data_temp:", data_temp
                # print "p0:", p0
                print(' '*20 +"p0 = " + np.array_str(p0, precision=4))
            # plot_guess = True  # This is to disable plotting the guess function
            if verbose and plot:
                plt.figure('CCD data')
                linewidth = 3
                x_vals = np.linspace(data_temp[0, 0], data_temp[-1, 0], num=500)
                if elem != 0:
                    try:
                        plt.plot(x_vals, gauss(x_vals, *p0),
                                 plt.gca().get_lines()[-1].get_color() + '--'  # I don't really know. Mostly
                                 # just looked around at what functions
                                 # matplotlib has...
                                 , linewidth=linewidth)
                    except:  # to prevent weird mac issues with the matplotlib things?
                        plt.plot(x_vals, gauss(x_vals, *p0), '--', linewidth=linewidth)

                else:
                    plt.plot(x_vals, gauss(x_vals, *p0), '--', linewidth=linewidth)

            try:
                # 11/1/16
                # needed to bump maxfev up to 2k because a sideband wasn't being fit
                # Fix for sb 106
                # 05-23 Loren 10nm\hsg_640_Perp352seq_spectrum.txt
                coeff, var_list = curve_fit(
                    gauss, data_temp[:, 0], data_temp[:, 1], p0=p0, maxfev = 2000)
            except Exception as e:
                if verbose:
                    print("\tThe fit failed:")
                    print("\t\t", e)
                    print("\tFitting region: {}->{}".format(peakIdx-window, peakIdx+window))
                    # print "I couldn't fit", elem
                    # print "It's sideband", num
                    # print "In file", self.fname
                    # print "because", e
                    # print "wanted to fit xindx", peakIdx, "+-", window
                self.sb_list[elem] = None
                continue # This will ensure the rest of the loop is not run without an actual fit.

            coeff[1] = abs(coeff[1])  # The amplitude could be negative if the linewidth is negative
            coeff[2] = abs(coeff[2])  # The linewidth shouldn't be negative
            if verbose:
                print("\tFit successful: ", end=' ')
                print("p = " + np.array_str(coeff, precision=4))
                # print "coeffs:", coeff
                # print "sigma for {}: {}".format(self.sb_list[elem], coeff[2])
            if 10e-4 > coeff[2] > 10e-6:
                try:
                    sb_fits.append(np.hstack((self.sb_list[elem], coeff, np.sqrt(np.diag(var_list)))))
                except RuntimeWarning:
                    sb_fits.append(np.hstack((self.sb_list[elem], coeff, np.sqrt(np.abs(np.diag(var_list))))))

                # the var_list wasn't approximating the error well enough, even when using sigma and absoluteSigma
                # self.sb_guess[elem, 2] is the relative error as calculated by the guess_sidebands method
                # coeff[1] is the area from the fit.  Therefore, the product should be the absolute error
                # of the integrated area of the sideband.  The other errors are still underestimated.
                #
                # 1/12/18 note: So it looks like what hunter did is calculate an error estimate
                # for the strength/area by the quadrature sum of errors of the points in the peak
                # (from like 813 in guess_sidebands:
                #    error_est = np.sqrt(sum([i ** 2 for i in error[found_index - 1:found_index + 2]])) / (
                # Where the error is what comes from the CCD by averaging 4 spectra. As far as I can tell,
                # it doesn't currently pull in the dark counts or anything like that, except maybe
                # indirectly since it'll cause the variations in the peaks
                sb_fits[-1][6] = self.sb_guess[elem, 2] * coeff[1]
                if verbose:
                    print("\tRel.Err: {:.4e}  |  Abs.Err: {:.4e}".format(
                        self.sb_guess[elem, 2], coeff[1] * self.sb_guess[elem, 2]
                    ))
                    print()
                    # print "The rel. error guess is", self.sb_guess[elem, 2]
                    # print "The abs. error guess is", coeff[1] * self.sb_guess[elem, 2]

                # The error from self.sb_guess[elem, 2] is a relative error
            if plot and verbose:
                plt.figure('CCD data')
                linewidth = 5
                x_vals = np.linspace(data_temp[0, 0], data_temp[-1, 0], num=500)
                if elem != 0:
                    try:
                        plt.plot(x_vals, gauss(x_vals, *coeff),
                                 plt.gca().get_lines()[-1].get_color() + '--'  # I don't really know. Mostly
                                 # just looked around at what functions
                                 # matplotlib has...
                                 , linewidth=linewidth)
                    except:  # to prevent weird mac issues with the matplotlib things?
                        plt.plot(x_vals, gauss(x_vals, *coeff), '--', linewidth=linewidth)

                else:
                    plt.plot(x_vals, gauss(x_vals, *coeff), '--', linewidth=linewidth)
        sb_fits_temp = np.asarray(sb_fits)
        reorder = [0, 1, 5, 2, 6, 3, 7, 4, 8]
        # Reorder the list to put the error of the i-th parameter as the i+1th.
        try:
            sb_fits = sb_fits_temp[:, reorder]
            # if verbose: print "The abs. error guess is", sb_fits[:, 0:5]
        except:
            raise RuntimeError("No sidebands to fit?")

        # Going to label the appropriate row with the sideband
        self.sb_list = sorted(list([x for x in self.sb_list if x is not None]))
        sb_names = np.vstack(self.sb_list)

        # Sort by SB order
        sorter = np.argsort(sb_fits[:, 0])
        self.sb_results = np.array(sb_fits[sorter, :7])

        if verbose:
            print("\tsb_results:")
            print("\t\t" + ("{:^5s}" + ("{:^12s}")*(self.sb_results.shape[1]-1)).format(
                "SB", "Cen.En.", "", "Area", "", "Width",""))
            for line in self.sb_results:
                print('\t\t[' + ("{:^5.0f}"+ "{:<12.4g}"*(line.size-1)).format(*line) + ']')
            print('-'*19)
        self.full_dict = {}
        for sb in self.sb_results:
            self.full_dict[sb[0]] = np.asarray(sb[1:])

    def infer_frequencies(self, nir_units="wavenumber", thz_units="GHz", bad_points=-2):
        """
        This guy tries to fit the results from fit_sidebands to a line to get the relevant frequencies
        :param nir_units: What units do you want this to output?
        :type nir_units: 'nm', 'wavenumber', 'eV', 'THz'
        :param thz_units: What units do you want this to output for the THz?
        :type thz_units: 'GHz', 'wavenumber', 'meV'
        :param bad_points: How many more-positive order sidebands shall this ignore?
        :type bad_points: int
        :return: freqNIR, freqTHz, the frequencies in the appropriate units
        """
        # force same units for in dict
        freqNIR, freqTHz = calc_laser_frequencies(self, "wavenumber", "wavenumber", bad_points)

        self.parameters["calculated NIR freq (cm-1)"] = "{}".format(freqNIR, nir_units)
        self.parameters["calculated THz freq (cm-1)"] = "{}".format(freqTHz, freqTHz)
        freqNIR, freqTHz = calc_laser_frequencies(self, nir_units, thz_units, bad_points)
        return freqNIR, freqTHz

    def save_processing(self, file_name, folder_str, marker='', index='', verbose=''):
        """
        This will save all of the self.proc_data and the results from the
        fitting of this individual file.

        Format:
        spectra_fname = file_name + '_' + marker + '_' + str(index) + '.txt'
        fit_fname = file_name + '_' + marker + '_' + str(index) + '_fits.txt'

        Inputs:
        file_name = the beginning of the file name to be saved
        folder_str = the location of the folder where the file will be saved,
                     will create the folder, if necessary.
        marker = I...I don't know what this was originally for
        index = used to keep these files from overwriting themselves when in a
                list

        Outputs:
        Two files:
            self.proc_data = the continuous spectrum
            self.sb_results = the individual sideband details

        :param file_name: The base name for the saved file
        :type file_name: str
        :param folder_str: The full name for the folder hte file is saved it.  Folder can be created
        :type folder_str: str
        :param marker: Marker for the file, appended to file_name, often the self.parameters['series']
        :type marker: str
        :param index: used to keep these files from overwriting themselves when marker is the same
        :type index: str or int
        :return: None
        """
        try:
            os.mkdir(folder_str)
        except OSError as e:
            if e.errno == errno.EEXIST:
                pass
            else:
                raise
        temp = np.array(self.sb_results)

        ampli = np.array([temp[:, 3] / temp[:, 5]])  # But [:, 3] is already area?
        # (The old name was area)
        # I think it must be amplitude
        temp[:, 5:7] = temp[:, 5:7] * 1000  # For meV linewidths
        if verbose:
            print("sb_results", self.sb_results.shape)
            print("ampli", ampli.shape)
        save_results = np.hstack((temp, ampli.T))

        spectra_fname = file_name + '_' + marker + '_' + str(index) + '.txt'
        fit_fname = file_name + '_' + marker + '_' + str(index) + '_fits.txt'
        self.save_name = spectra_fname

        self.parameters['addenda'] = self.addenda
        self.parameters['subtrahenda'] = self.subtrahenda
        try:
            parameter_str = json.dumps(self.parameters, sort_keys=True, indent=4, separators=(',', ': '))
        except:
            print("Source: EMCCD_image.save_images\nJSON FAILED")
            print("Here is the dictionary that broke JSON:\n", self.parameters)
            return
        parameter_str = parameter_str.replace('\n', '\n#')

        num_lines = parameter_str.count('#')  # Make the number of lines constant so importing is easier
        # for num in range(99 - num_lines): parameter_str += '\n#'
        parameter_str += '\n#' * (99 - num_lines)
        origin_import_spec = '\nNIR frequency,Signal,Standard error\neV,arb. u.,arb. u.'
        spec_header = '#' + parameter_str + origin_import_spec

        origin_import_fits  = '\nSideband,Center energy,error,Sideband strength,error,Linewidth,error,Amplitude'
        origin_import_fits += '\norder,eV,,arb. u.,,meV,,arb. u.'
        origin_import_fits += "\n{},,,{},,,".format(marker, marker)
        fits_header = '#' + parameter_str + origin_import_fits

        # print "DEBUG: in saving", folder_str, ",", spectra_fname

        np.savetxt(os.path.join(folder_str, spectra_fname), self.proc_data, delimiter=',',
                   header=spec_header, comments='', fmt='%0.6e')
        np.savetxt(os.path.join(folder_str, fit_fname), save_results, delimiter=',',
                   header=fits_header, comments='', fmt='%0.6e')
        if verbose:
            print("Save image.\nDirectory: {}".format(os.path.join(folder_str, spectra_fname)))
